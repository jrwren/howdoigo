= How Do I Go

Welcome to How do I Go.

You can find this book on-line at: TODO

It is licensed under the Creative Commons Attribution-Non Commercial-Share
Alike 3.0 license.

== What is this?

This is a FAQ which deals specifically with questions of the form "How do I...?" or "Why does...?"

The inspiration for this documentation is perlfaq. While many sections of perlfaq are answered adequately in other places such as http://golang.org/doc/effective_go.html[Effective Go] and the http://golang.org/doc/faq[Go FAQ], the example code in sections 4, 5 and 6 of perlfaq are not as well represented. This document is an attempt to rectify that underrepresentation.

Wherever possible the http://golang.org/ref/spec[Go Programming Language Specification] is referenced.


== Data: Numbers

=== Why does division give wrong answers?

First, if you have never read anything about how floating point numbers are represented in a machine, stop now, go to a search engine and search for "what every programmer should know about floating point". For bonus fun reading, read about an Excel 2007 bug: http://www.joelonsoftware.com/items/2007/09/26b.html or Eric Lipperts explaination which is a great read: http://blogs.msdn.com/b/ericlippert/archive/2005/01/20/fun-with-floating-point-arithmetic-part-five.aspx

When doing any math, always be aware of what types are being used.

Integer math results in integers.
e.g.
--------------------------------------
fmt.Println(3/9)
0
--------------------------------------

Constants in Go may be typed or untyped. Untyped constants are converted to appropriate type when needed. http://golang.org/ref/spec#Constants[GPLS Constants]

When printing floating point numbers, always be aware of what precision is used.

If you are using 32bit floats, you will hit rounding errors much sooner than 64bit. Literals default to 64bit. (This is not really true. The spec says floating point constants are reprecented with a mantissa of at least 256 bits. At runtime values are converted and 64bit math operations are used. This is also not really true. The floating point units on many CPUs use 80bit IEEE operations.)

e.g.
--------------------------------------
	fmt.Printf("%.20f\n",float32(3)/9)
    0.33333334326744079590
	fmt.Printf("%.20f\n",float64(3)/9)
    0.33333333333333331483
	fmt.Printf("%.20f\n",3.0/9)
    0.33333333333333331483
--------------------------------------


===  How do I make int() work?

It does work. The numbers may not be what you think. See the previous question.

1.0 minus nine tenths minus one tenth is represented as a number very close to zero, but not zero.

e.g.
--------------------------------------
fmt.Println(int(1.0-0.9-0.1))
--------------------------------------
.results in a compiler error:

=====================================================================
constant -8.45304e-132 truncated to integer
=====================================================================

A floating point constant which is zero is convertible.

e.g.
--------------------------------------
fmt.Println(int(5.0-1.0-4.0))
0
--------------------------------------


=== Why isn't my octal data interpreted correctly?

strconv.Atoi doesn't know about literal language prefixes.

e.g.
--------------------------------------
mine := int64(0600)
claim, _ := strconv.Atoi("0600")
fmt.Println(mine == claim)
false
--------------------------------------

strconv.Atoi is a convenience method for ParseInt(s, 10, 0).  Where 10 and 0 are base and bit size.  Use base 8 for converting octal.

e.g.
--------------------------------------
mine := int64(0600)
claim, _ := strconv.ParseInt("0600", 8, 0)
fmt.Println(mine == claim)
true
--------------------------------------

A side note: The bit size parameter does not change the return type of ParseInt (read the spec and you'll know that it wouldn't). It causes ParseInt to return a value out of range error.

=== Does go have a round() function? What about ceil() and floor()? Trig functions?

Look at the http://golang.org/pkg/math/[math package].

e.g.
--------------------------------------
import "math"
...
fmt.Println(math.Ciel(1.6))
fmt.Println(math.Floor(1.6))
fmt.Println(math.Round(1.6))

--------------------------------------

See also, the above question about int().

Combining these two questions we have some interesting results:

e.g.
--------------------------------------
fmt.Println(int(math.Floor(1.0-0.9-0.1)))
-1
--------------------------------------

In the question about int() we said that int() cannot truncate and that the floating representation of 1.0-0.9-0.1 is a tiny negative number. Calling Floor on that tiny negative number floors it to -1.

Calling Ciel on that tiny negative number ciellings it to 0.
--------------------------------------
fmt.Println(int(math.Ciel(1.0-0.9-0.1)))
0
--------------------------------------

Trig functions exist and suffer from the same limitations of floating point numbers as everything else. (Why isn't math.Sin(math.Pi) == 0? Why isn't math.Cos(math.Pi/2) == 0?)  See the above question about int().

--------------------------------------
fmt.Println(math.Cos(math.Pi/2))
6.123233995736757e-17
fmt.Println(math.Sin(math.Pi))
1.2246467991473515e-16
fmt.Println(math.Cos(0))
1
fmt.Println(math.Sin(math.Pi/2))
1
--------------------------------------

For the same reason, trig identities will not always be exact. No really, go read the "What Every Programmer Should Know About Floating-Point Arithmetic" publication right now.

--------------------------------------
a30 := math.Pi/6
if (math.Sin(a30) == math.Sqrt(3)/2) { // is equal
	fmt.Println("sin(30)==âˆš3/2")
}
i := 0.01
if (math.Tan(i) == math.Sin(i)/math.Cos(i)) { // is not equal for all values i
    fmt.Println("Identity not held.")
}
--------------------------------------

You may be tempted to compare using some epsilon value and this works for some cases, but really, go read WEPSKAFPA.

=== How do I convert between numeric representations/bases/radixes?

You can use literals with the 0 prefix for octal, the 0x prefix for hexadecimal.  http://golang.org/ref/spec#Integer_literals

You can use strconv.ParseInt to parse hexadecimal and octal. https://www.golang.org/pkg/strconv/#ParseInt

--------------------------------------
deadbeef := "deadbeef"
fmt.Println(strconv.ParseUint(deadbeef, 16, 32))
3735928559 <nil>
--------------------------------------

Convert from decimal to hexadecimal:

--------------------------------------
hex := fmt.Sprintf("%x", uint(3735928559))  // hex is "deadbeef"
--------------------------------------

From octal to decimal

--------------------------------------
deadbeef := "33653337357"
fmt.Println(strconv.ParseUint(deadbeef, 8, 32))
3735928559 <nil>
--------------------------------------

Note the use of unsigned integer parsing. If you want to treat your parsed number as signed you will need to cast it.

--------------------------------------
deadbeef := "33653337357"
val,_:=strconv.ParseUint(deadbeef, 8, 32)
fmt.Println(int(val))
-559038737
--------------------------------------

How do I convert from binary to decimal?

TODO

=== Why doesn't & work the way I want it to?

NA?

=== How do I multiply matrices?

Use https://github.com/gonum/matrix

=== How do I perform an operation on a series of integers?

Go isn't a functional programming language. There is no generic map function. Use a for loop.

--------------------------------------
results := make([]int, len(array))
for i:=0; i< len(array); i++ {
    results[i] = somefunc(array[i])
}
--------------------------------------

=== How can I output roman numerals

TODO

=== Why aren't my random numbers random

The "math/rand" package generates pseudo-random numbers. For cryptographic work use the crypto/rand package.

You can seed the "math/rand" package by calling rand.Seed(). A common seed which will not repeat without clock manipulation is time.Now().UnixNano().

--------------------------------------
r := rand.New(rand.NewSource(time.Now().UnixNano()))
fmt.Println(r.Int())
--------------------------------------

=== How do I get a random number between X and Y?

Use rand.Intn(Y-X) and add X.

e.g. between 1 and 10:
--------------------------------------
num := rand.Intn(10) + 1
--------------------------------------
This is 1 through 10 inclusive.

The rand.Intn() returns [0,N) so Intn(10) returns a number from the set of integers from 0 through N-1.

== Data: Dates

Note that the playground at http://play.golang.org may not have the time that you think it is. time.Now() returns 2009-11-10 23:00:00 +0000 UTC as I write this. It is conceivable that this return value may change in the future.

=== How do I find the day or week of the year?

Time.YearDay() returns the day of the year for a time.

e.g.
--------------------------------------
fmt.Println(time.Now())
fmt.Println(time.Now().YearDay())
2009-11-10 23:00:00 +0000 UTC
314
--------------------------------------

The second return value of ISOWeek() is the week of the year.

e.g.
--------------------------------------
fmt.Println(time.Now())
fmt.Println(time.Now().ISOWeek())
2009-11-10 23:00:00 +0000 UTC
2009 46
--------------------------------------

=== How do I find the current century or millennium?

Do some math on the result of Year().

e.g.
--------------------------------------
fmt.Println("This is century", time.Now().Year() / 100 + 1)
fmt.Println("This is millenium", time.Now().Year() / 1000 + 1)
--------------------------------------

=== How do I compare two dates and find the difference?

The time package supports math functions on times and returns durations. There are functions such as Before, After, and Equal to test which time instances are before, after, or equal to the compared time.

e.g.
--------------------------------------
var now = time.Now()
var date1, _ = time.Parse(someParsableDateString)
if date1.Before(now) {
    fmt.Println("The date was in the past")
}
fmt.Println(date1.Sub(now))
The date was in the past
62425h0m0s
--------------------------------------

=== How can I take a string and turn it into epoch seconds?

The time package has a Parse function which returns a new time value. That time value has a Unix function.

e.g.
--------------------------------------
var date1, _ = time.Parse(someParsableDateString)
var seconds = date1.Unix()
--------------------------------------

=== How can I find the Julian Day?

A duckduckgo search yields this playground post: http://play.golang.org/p/ocYFWY7kpo

=== How do I find yesterday's date?

Use a calendar library if you want to catch all the edge cases. Dates and times are always more complex than you may think. I'm not aware of anything like Noda Time for golang, but if you really want to get it right, then you will need to write or use something like it.

Or...

Use time.AddDate(0,0,-1)

=== Does Go have a Year 2000 or 2038 problem?

Go came out well after 2000, so I sure hope not.

Go uses int64 to store time values, even on 32bit machines. There should be no 2038 problem.

== Data: Strings

Before considering some of these items, it will be useful to understand what kind of strings Go uses. This blog post is a good explaination: https://blog.golang.org/strings

=== How do I validate input?

TODO

=== How do I unescape a string?

It depends on what you mean by unescape. What is escaped? utf8? c-strings, go strings, other?

=== How do I remove consecutive pairs of characters?

In Go, you use a loop.

Many other languages suggest a regular expression.

It is up to the reader to decide which is better and why.

=== How do I exapnd function calls in a string?

You don't.

=== How do I find matching/nesting anything?

In Go, you use a loop and a simple state machine.

Many other languages suggest a regular expression.

=== How do I reverse a string?

In Go, you use a loop.

Many other languages have a generic reverse function.

=== How do I expand tabs in a string?

In Go, you use a loop.

Many other languages suggest a regular expression.

=== How do I reformat a paragraph?

Create a buffered string output and count width of characters yourself.

=== How do I access or change N characters of a string?

Strings are slices of runes. Runes are utf8 characters. You can slice a string.

--------------------------------------
s := "Just another gopher"
j := s[0:4]
g := s[13:19]
fmt.Println(g, "in the hole!")
--------------------------------------

In go, strings are immutable. This is very familiar if you come from python, C#, or Java, but may be unfamiliar if you come from C or ruby.

--------------------------------------
s := "Just another gopher"
s[0:3] = "yes" // cannot assign to s[0:3]
--------------------------------------

To change characters, create a new string.

--------------------------------------
s := "Just another gopher"
s2 := "yet" + s[4:]
fmt.Println(s2)
--------------------------------------

=== How do I change the Nth occurrence of something?

Find the Nth yourself.

// vim: set syntax=asciidoc:
