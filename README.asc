= How Do I Go

Welcome to How do I Go.

You can find this book on-line at: TODO

It is licensed under the Creative Commons Attribution-Non Commercial-Share
Alike 3.0 license.

== What is this?

This is a FAQ which deals specifically with questions of the form "How do I...?" or "Why does...?"

The inspiration for this documentation is perlfaq. While many sections of perlfaq are answered adequately in other places such as http://golang.org/doc/effective_go.html[Effective Go] and the http://golang.org/doc/faq[Go FAQ], the example code in sections 4, 5 and 6 of perlfaq are not as well represented. This document is an attempt to rectify that underrepresentation.

Wherever possible the http://golang.org/ref/spec[Go Programming Language Specification] is referenced.


== Data Manipulation

=== Why does division give wrong answers?

First, if you have never read anything about how floating point numbers are represented in a machine, stop now, go to a search engine and search for "what every programmer should know about floating point". For bonus fun reading, read about an Excel 2007 bug: http://www.joelonsoftware.com/items/2007/09/26b.html or Eric Lipperts explaination which is a great read: http://blogs.msdn.com/b/ericlippert/archive/2005/01/20/fun-with-floating-point-arithmetic-part-five.aspx

When doing any math, always be aware of what types are being used.

Integer math results in integers.
e.g.
--------------------------------------
fmt.Println(3/9)
0
--------------------------------------

Constants in Go may be typed or untyped. Untyped constants are converted to appropriate type when needed. http://golang.org/ref/spec#Constants[GPLS Constants]

When printing floating point numbers, always be aware of what precision is used.

If you are using 32bit floats, you will hit rounding errors much sooner than 64bit. Literals default to 64bit. (This is not really true. The spec says floating point constants are reprecented with a mantissa of at least 256 bits. At runtime values are converted and 64bit math operations are used. This is also not really true. The floating point units on many CPUs use 80bit IEEE operations.)

e.g.
--------------------------------------
	fmt.Printf("%.20f\n",float32(3)/9)
    0.33333334326744079590
	fmt.Printf("%.20f\n",float64(3)/9)
    0.33333333333333331483
	fmt.Printf("%.20f\n",3.0/9)
    0.33333333333333331483
--------------------------------------


===  How do I make int() work?

It does work. The numbers may not be what you think. See the previous question.

1.0 minus nine tenths minus one tenth is represented as a number very close to zero, but not zero.

e.g.
--------------------------------------
fmt.Println(int(1.0-0.9-0.1))
--------------------------------------
.results in a compiler error:

=====================================================================
constant -8.45304e-132 truncated to integer
=====================================================================

A floating point constant which is zero is convertible.

e.g.
--------------------------------------
fmt.Println(int(5.0-1.0-4.0))
0
--------------------------------------


=== Why isn't my octal data interpreted correctly?

strconv.Atoi doesn't know about literal language prefixes.

e.g.
--------------------------------------
mine := int64(0600)
claim, _ := strconv.Atoi("0600")
fmt.Println(mine == claim)
false
--------------------------------------

strconv.Atoi is a convenience method for ParseInt(s, 10, 0).  Where 10 and 0 are base and bit size.  Use base 8 for converting octal.

e.g.
--------------------------------------
mine := int64(0600)
claim, _ := strconv.ParseInt("0600", 8, 0)
fmt.Println(mine == claim)
true
--------------------------------------

A side note: The bit size parameter does not change the return type of ParseInt (read the spec and you'll know that it wouldn't). It causes ParseInt to return a value out of range error.

=== Does go have a round() function? What about ceil() and floor()? Trig functions?

Look at the http://golang.org/pkg/math/[math package].

e.g.
--------------------------------------
import "math"
...
fmt.Println(math.Ciel(1.6))
fmt.Println(math.Floor(1.6))
fmt.Println(math.Round(1.6))

--------------------------------------

See also, the above question about int().

Combining these two questions we have some interesting results:

e.g.
--------------------------------------
fmt.Println(int(math.Floor(1.0-0.9-0.1)))
-1
--------------------------------------

In the question about int() we said that int() cannot truncate and that the floating representation of 1.0-0.9-0.1 is a tiny negative number. Calling Floor on that tiny negative number floors it to -1.

Calling Ciel on that tiny negative number ciellings it to 0.
--------------------------------------
fmt.Println(int(math.Ciel(1.0-0.9-0.1)))
0
--------------------------------------

Trig functions exist and suffer from the same limitations of floating point numbers as everything else. (Why isn't math.Sin(math.Pi) == 0? Why isn't math.Cos(math.Pi/2) == 0?)  See the above question about int().

--------------------------------------
fmt.Println(math.Cos(math.Pi/2))
6.123233995736757e-17
fmt.Println(math.Sin(math.Pi))
1.2246467991473515e-16
fmt.Println(math.Cos(0))
1
fmt.Println(math.Sin(math.Pi/2))
1
--------------------------------------

For the same reason, trig identities will not always be exact. No really, go read the "What Every Programmer Should Know About Floating-Point Arithmetic" publication right now.

--------------------------------------
a30 := math.Pi/6
if (math.Sin(a30) == math.Sqrt(3)/2) { // is equal
	fmt.Println("sin(30)==âˆš3/2")
}
i := 0.01
if (math.Tan(i) == math.Sin(i)/math.Cos(i)) { // is not equal for all values i
    fmt.Println("Identity not held.")
}
--------------------------------------

You may be tempted to compare using some epsilon value and this works for some cases, but really, go read WEPSKAFPA.

=== How do I convert between numeric representations/bases/radixes?

You can use literals with the 0 prefix for octal, the 0x prefix for hexadecimal.  http://golang.org/ref/spec#Integer_literals

You can use strconv.ParseInt to parse hexadecimal and octal. https://www.golang.org/pkg/strconv/#ParseInt

--------------------------------------
deadbeef := "deadbeef"
fmt.Println(strconv.ParseUint(deadbeef, 16, 32))
3735928559 <nil>
--------------------------------------

Convert from decimal to hexadecimal:

--------------------------------------
hex := fmt.Sprintf("%x", uint(3735928559))  // hex is "deadbeef"
--------------------------------------

From octal to decimal

--------------------------------------
deadbeef := "33653337357"
fmt.Println(strconv.ParseUint(deadbeef, 8, 32))
3735928559 <nil>
--------------------------------------

Note the use of unsigned integer parsing. If you want to treat your parsed number as signed you will need to cast it.

--------------------------------------
deadbeef := "33653337357"
val,_:=strconv.ParseUint(deadbeef, 8, 32)
fmt.Println(int(val))
-559038737
--------------------------------------

How do I convert from binary to decimal?

TODO

=== Why doesn't & work the way I want it to?

NA?

=== How do I multiply matrices?

Use https://github.com/gonum/matrix

=== How do I perform an operation on a series of integers?

Go isn't a functional programming language. There is no generic map function. Use a for loop.

--------------------------------------
results := make([]int, len(array))
for i:=0; i< len(array); i++ {
    results[i] = somefunc(array[i])
}
--------------------------------------

=== How can I output roman numerals

TODO

=== Why aren't my random numbers random

The "math/rand" package generates pseudo-random numbers. For cryptographic work use the crypto/rand package.

You can seed the "math/rand" package by calling rand.Seed(). A common seed which will not repeat without clock manipulation is time.Now().UnixNano().

--------------------------------------
r := rand.New(rand.NewSource(time.Now().UnixNano()))
fmt.Println(r.Int())
--------------------------------------

=== How do I get a random number between X and Y?

Use rand.Intn(Y-X) and add X.

e.g. between 1 and 10:
--------------------------------------
num := rand.Intn(10) + 1
--------------------------------------
This is 1 through 10 inclusive.

The rand.Intn() returns [0,N) so Intn(10) returns a number from the set of integers from 0 through N-1.

== Data: Dates
=== How do I find the day or week of the year?

Time.YearDay() returns the day of the year for a time.

e.g.
--------------------------------------
fmt.Println(time.Now())
fmt.Println(time.Now().YearDay())
2009-11-10 23:00:00 +0000 UTC
314
--------------------------------------

The second return value of ISOWeek() is the week of the year.

e.g.
--------------------------------------
fmt.Println(time.Now())
fmt.Println(time.Now().ISOWeek())
2009-11-10 23:00:00 +0000 UTC
2009 46
--------------------------------------

=== How do I find the current century or millennium?


