= How Do I Go

Welcome to How do I Go.

You can find this book on-line at: TODO

It is licensed under the Creative Commons Attribution-Non Commercial-Share
Alike 3.0 license.

== What is this?

This is a FAQ which deals specifically with questions of the form "How do I...?" or "Why does...?"

The inspiration for this documentation is perlfaq. While many sections of perlfaq are answered adequately in other places such as http://golang.org/doc/effective_go.html[Effective Go] and the http://golang.org/doc/faq[Go FAQ], the example code in sections 4, 5 and 6 of perlfaq are not as well represented. This document is an attempt to rectify that underrepresentation.

Wherever possible the http://golang.org/ref/spec[Go Programming Language Specification] is referenced.


== Data: Numbers

=== Why does division give wrong answers?

First, if you have never read anything about how floating point numbers are represented in a machine, stop now, go to a search engine and search for "what every programmer should know about floating point". For bonus fun reading, read about an Excel 2007 bug: http://www.joelonsoftware.com/items/2007/09/26b.html or Eric Lipperts explaination which is a great read: http://blogs.msdn.com/b/ericlippert/archive/2005/01/20/fun-with-floating-point-arithmetic-part-five.aspx

When doing any math, always be aware of what types are being used.

Integer math results in integers.
e.g.
--------------------------------------
fmt.Println(3/9)
0
--------------------------------------

Constants in Go may be typed or untyped. Untyped constants are converted to appropriate type when needed. http://golang.org/ref/spec#Constants[GPLS Constants]

When printing floating point numbers, always be aware of what precision is used.

If you are using 32bit floats, you will hit rounding errors much sooner than 64bit. Literals default to 64bit. (This is not really true. The spec says floating point constants are reprecented with a mantissa of at least 256 bits. At runtime values are converted and 64bit math operations are used. This is also not really true. The floating point units on many CPUs use 80bit IEEE operations.)

e.g.
--------------------------------------
	fmt.Printf("%.20f\n",float32(3)/9)
    0.33333334326744079590
	fmt.Printf("%.20f\n",float64(3)/9)
    0.33333333333333331483
	fmt.Printf("%.20f\n",3.0/9)
    0.33333333333333331483
--------------------------------------


===  How do I make int() work?

It does work. The numbers may not be what you think. See the previous question.

1.0 minus nine tenths minus one tenth is represented as a number very close to zero, but not zero.

e.g.
--------------------------------------
fmt.Println(int(1.0-0.9-0.1))
--------------------------------------
.results in a compiler error:

=====================================================================
constant -8.45304e-132 truncated to integer
=====================================================================

A floating point constant which is zero is convertible.

e.g.
--------------------------------------
fmt.Println(int(5.0-1.0-4.0))
0
--------------------------------------


=== Why isn't my octal data interpreted correctly?

strconv.Atoi doesn't know about literal language prefixes.

e.g.
--------------------------------------
mine := int64(0600)
claim, _ := strconv.Atoi("0600")
fmt.Println(mine == claim)
false
--------------------------------------

strconv.Atoi is a convenience method for ParseInt(s, 10, 0).  Where 10 and 0 are base and bit size.  Use base 8 for converting octal.

e.g.
--------------------------------------
mine := int64(0600)
claim, _ := strconv.ParseInt("0600", 8, 0)
fmt.Println(mine == claim)
true
--------------------------------------

A side note: The bit size parameter does not change the return type of ParseInt (read the spec and you'll know that it wouldn't). It causes ParseInt to return a value out of range error.

=== Does go have a round() function? What about ceil() and floor()? Trig functions?

Look at the http://golang.org/pkg/math/[math package].

e.g.
--------------------------------------
import "math"
...
fmt.Println(math.Ciel(1.6))
fmt.Println(math.Floor(1.6))
fmt.Println(math.Round(1.6))

--------------------------------------

See also, the above question about int().

Combining these two questions we have some interesting results:

e.g.
--------------------------------------
fmt.Println(int(math.Floor(1.0-0.9-0.1)))
-1
--------------------------------------

In the question about int() we said that int() cannot truncate and that the floating representation of 1.0-0.9-0.1 is a tiny negative number. Calling Floor on that tiny negative number floors it to -1.

Calling Ciel on that tiny negative number ciellings it to 0.
--------------------------------------
fmt.Println(int(math.Ciel(1.0-0.9-0.1)))
0
--------------------------------------

Trig functions exist and suffer from the same limitations of floating point numbers as everything else. (Why isn't math.Sin(math.Pi) == 0? Why isn't math.Cos(math.Pi/2) == 0?)  See the above question about int().

--------------------------------------
fmt.Println(math.Cos(math.Pi/2))
6.123233995736757e-17
fmt.Println(math.Sin(math.Pi))
1.2246467991473515e-16
fmt.Println(math.Cos(0))
1
fmt.Println(math.Sin(math.Pi/2))
1
--------------------------------------

For the same reason, trig identities will not always be exact. No really, go read the "What Every Programmer Should Know About Floating-Point Arithmetic" publication right now.

--------------------------------------
a30 := math.Pi/6
if (math.Sin(a30) == math.Sqrt(3)/2) { // is equal
	fmt.Println("sin(30)==âˆš3/2")
}
i := 0.01
if (math.Tan(i) == math.Sin(i)/math.Cos(i)) { // is not equal for all values i
    fmt.Println("Identity not held.")
}
--------------------------------------

You may be tempted to compare using some epsilon value and this works for some cases, but really, go read WEPSKAFPA.

=== How do I convert between numeric representations/bases/radixes?

You can use literals with the 0 prefix for octal, the 0x prefix for hexadecimal.  http://golang.org/ref/spec#Integer_literals

You can use strconv.ParseInt to parse hexadecimal and octal. https://www.golang.org/pkg/strconv/#ParseInt

--------------------------------------
deadbeef := "deadbeef"
fmt.Println(strconv.ParseUint(deadbeef, 16, 32))
3735928559 <nil>
--------------------------------------

Convert from decimal to hexadecimal:

--------------------------------------
hex := fmt.Sprintf("%x", uint(3735928559))  // hex is "deadbeef"
--------------------------------------

From octal to decimal

--------------------------------------
deadbeef := "33653337357"
fmt.Println(strconv.ParseUint(deadbeef, 8, 32))
3735928559 <nil>
--------------------------------------

Note the use of unsigned integer parsing. If you want to treat your parsed number as signed you will need to cast it.

--------------------------------------
deadbeef := "33653337357"
val,_:=strconv.ParseUint(deadbeef, 8, 32)
fmt.Println(int(val))
-559038737
--------------------------------------

How do I convert from binary to decimal?

TODO

=== Why doesn't & work the way I want it to?

NA?

=== How do I multiply matrices?

Use https://github.com/gonum/matrix

=== How do I perform an operation on a series of integers?

Go isn't a functional programming language. There is no generic map function. Use a for loop.

--------------------------------------
results := make([]int, len(array))
for i:=0; i< len(array); i++ {
    results[i] = somefunc(array[i])
}
--------------------------------------

=== How can I output roman numerals

TODO

=== Why aren't my random numbers random

The http://golang.org/pkg/math/rand["math/rand"] package generates pseudo-random numbers. For cryptographic work use the http://golang.org/pkg/crypto/rand[crypto/rand] package.

You can seed the "math/rand" package by calling rand.Seed(). A common seed which will not repeat without clock manipulation is time.Now().UnixNano().

--------------------------------------
r := rand.New(rand.NewSource(time.Now().UnixNano()))
fmt.Println(r.Int())
--------------------------------------

=== How do I get a random number between X and Y?

Use rand.Intn(Y-X) and add X.

e.g. between 1 and 10:
--------------------------------------
num := rand.Intn(10) + 1
--------------------------------------
This is 1 through 10 inclusive.

The rand.Intn() returns [0,N) so Intn(10) returns a number from the set of integers from 0 through N-1.

== Data: Dates

Note that the playground at http://play.golang.org may not have the time that you think it is. time.Now() returns 2009-11-10 23:00:00 +0000 UTC as I write this. It is conceivable that this return value may change in the future.

=== How do I find the day or week of the year?

Time.YearDay() returns the day of the year for a time.

e.g.
--------------------------------------
fmt.Println(time.Now())
fmt.Println(time.Now().YearDay())
2009-11-10 23:00:00 +0000 UTC
314
--------------------------------------

The second return value of ISOWeek() is the week of the year.

e.g.
--------------------------------------
fmt.Println(time.Now())
fmt.Println(time.Now().ISOWeek())
2009-11-10 23:00:00 +0000 UTC
2009 46
--------------------------------------

=== How do I find the current century or millennium?

Do some math on the result of Year().

e.g.
--------------------------------------
fmt.Println("This is century", time.Now().Year() / 100 + 1)
fmt.Println("This is millenium", time.Now().Year() / 1000 + 1)
--------------------------------------

=== How do I compare two dates and find the difference?

The time package supports math functions on times and returns durations. There are functions such as Before, After, and Equal to test which time instances are before, after, or equal to the compared time.

e.g.
--------------------------------------
var now = time.Now()
var date1, _ = time.Parse(someParsableDateString)
if date1.Before(now) {
    fmt.Println("The date was in the past")
}
fmt.Println(date1.Sub(now))
The date was in the past
62425h0m0s
--------------------------------------

=== How can I take a string and turn it into epoch seconds?

The http://golang.org/pkg/time[time] package has a Parse function which returns a new time value. That time value has a Unix function.

e.g.
--------------------------------------
var date1, _ = time.Parse(someParsableDateString)
var seconds = date1.Unix()
--------------------------------------

=== How can I find the Julian Day?

A duckduckgo search yields this playground post: http://play.golang.org/p/ocYFWY7kpo

=== How do I find yesterday's date?

Use a calendar library if you want to catch all the edge cases. Dates and times are always more complex than you may think. I'm not aware of anything like Noda Time for golang, but if you really want to get it right, then you will need to write or use something like it.

Or...

Use time.AddDate(0,0,-1)

=== Does Go have a Year 2000 or 2038 problem?

Go came out well after 2000, so I sure hope not.

Go uses int64 to store time values, even on 32bit machines. There should be no 2038 problem.

== Data: Strings

Before considering some of these items, it will be useful to understand what kind of strings Go uses. This blog post is a good explaination: https://blog.golang.org/strings

=== How do I validate input?

TODO

=== How do I unescape a string?

It depends on what you mean by unescape. What is escaped? utf8? c-strings, go strings, other?

=== How do I remove consecutive pairs of characters?

In Go, you use a loop.

Many other languages suggest a regular expression.

It is up to the reader to decide which is better and why.

=== How do I expand function calls in a string?

You don't.

That said, the %v format specifier does the job nicely in an fmt.Sprintf call.

--------------------------------------
msg := fmt.Sprintf("now its: %v", time.Now())
--------------------------------------

=== How do I find matching/nesting anything?

In Go, you use a loop and a simple state machine.

Many other languages suggest a regular expression.

=== How do I reverse a string?

In Go, you use a loop.

Many other languages have a generic reverse function.

=== How do I expand tabs in a string?

In Go, you use a loop.

Many other languages suggest a regular expression.

=== How do I reformat a paragraph?

Create a buffered string output and count width of characters yourself.

=== How do I access or change N characters of a string?

Strings are slices of runes. Runes are utf8 characters. You can slice a string.

--------------------------------------
s := "Just another gopher"
j := s[0:4]
g := s[13:19]
fmt.Println(g, "in the hole!")
--------------------------------------

In go, strings are immutable. This is very familiar if you come from python, C#, or Java, but may be unfamiliar if you come from C or ruby.

--------------------------------------
s := "Just another gopher"
s[0:3] = "yes" // cannot assign to s[0:3]
--------------------------------------

To change characters, create a new string.

--------------------------------------
s := "Just another gopher"
s2 := "yet" + s[4:]
fmt.Println(s2)
--------------------------------------

=== How do I change the Nth occurrence of something?

Find the Nth yourself.

--------------------------------------
package main

import (
	"bytes"
	"fmt"
	"strings"
)

func main() {
	const src = `Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec a diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante hendrerit. Donec et mollis dolor. Praesent et diam eget libero egestas mattis sit amet vitae augue. Nam tincidunt congue enim, ut porta lorem lacinia consectetur. Donec ut libero sed arcu vehicula ultricies a non tortor. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean ut gravida lorem. Ut turpis felis, pulvinar a semper sed, adipiscing id dolor. Pellentesque auctor nisi id magna consequat sagittis. Curabitur dapibus enim sit amet elit pharetra tincidunt feugiat nisl imperdiet. Ut convallis libero in urna ultrices accumsan. Donec sed odio eros. Donec viverra mi quis quam pulvinar at malesuada arcu rhoncus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. In rutrum accumsan ultricies. Mauris vitae nisi at sem facilisis semper ac in est.`
	
	count_sit := 0
	count_Donec := 0
	nth_sit := 3
	nth_Donec := 2
	var b bytes.Buffer
	
	for _,word:=range strings.Split(src, " ") {
		wrote:=false
		if word=="sit" {
			count_sit++
			if count_sit == nth_sit {
				b.WriteString("SIT!")
				wrote=true
			}
		} 
		if word == "Donec" {
			count_Donec++
			if count_Donec == nth_Donec { b.WriteString("ZOMGDONEC"); wrote = true }
		}
		if !wrote {
			b.WriteString(word)
		}
		b.WriteString(" ")
	}
	fmt.Println(b.String())
}
--------------------------------------

Optimizing the garbage created by caling strings.Split is an exercise left to the reader.

Note that other languages use a regular expression to do this operation.  Go can too.

--------------------------------------
    nth := 3
    count := 0
    src := "One fish two fish red fish blue fish"
    r := regexp.MustCompile(`(\w+)\s+fish\b`)
    for _, m := range r.FindAllStringSubmatch(src, -1) {
	    count++
        if (count == nth) {
            fmt.Printf("The third fish is a %s one.\n", m[0])
        }
    }
--------------------------------------

=== How can I count the number of occurrences of a substring within a string?

If you want to count the number of occurences of a single character in a string, you can simply loop and keep a counter:

--------------------------------------
	s := "ThisXlineXhasXsomeXx'sXinXit"
	count := 0
	for _, e := range s {
		if e == 'X' {
			count++
		}
	}
	fmt.Println(count, "Xs")
--------------------------------------

Or you could use strings.Count

--------------------------------------
	s := "ThisXlineXhasXsomeXx'sXinXit"
    fmt.Println(strings.Count(s, "X"), "Xs")
--------------------------------------

Note that strings.Count is the preferred method and it works with more than a single character.

=== How do I capitalize all the words on one line?

Call strings.Title.

--------------------------------------
    s := "gone with the wind's director"
    fmt.Println(strings.Title(s))
--------------------------------------

=== How can I split a character delimited string except when inside some character?

Use the https://golang.org/pkg/encoding/csv[encoding/csv] package. It is not just for comma separated files and it handles commas inside of quoted fields correctly.

--------------------------------------
    in := `first_name,last_name,username
"Rob","Pike",rob
Ken,Thompson,ken
"Robert","Griesemer","gri"
"jay,r",wren,"fuk,ka"
`
	r := csv.NewReader(strings.NewReader(in))

	for {
		record, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatal(err)
		}

		fmt.Println(record)
	}
--------------------------------------

=== How do I strip blank space from the beginning or end of a string?

Use strings.TrimSpace.

--------------------------------------
    s := "  some user may have entered this   "
    fmt.Println(strings.TrimSpace(s))
--------------------------------------

See also, all of the Trim* functions in the https://golang.org/pkg/strings[strings] package.

=== How do I pad a string with blanks or pad a number with zeroes?

The https://golang.org/pkg/fmt[fmt] package is short for format.

--------------------------------------
    fmt.Printf("%-10s%-10s%10s  %06.2f %06d\n","jay","raymond","wren", 20.0/3, 123)
    fmt.Printf("%-[5]*[1]s%-[5]*[2]s%[5]*[3]s  %0[6]*.[7]*[4]f %0[6]*[8]d\n","jay","raymond","wren", 20.0/3, 10, 6, 2, 123)
--------------------------------------

=== How do I extract selected columns from a string?

If you know the columns which contain the data, then you can slice the string.

--------------------------------------
    // column := line[startcolumn:end]
    line := "root     28550     2  0  2015 ?        00:00:04 [btrfs-worker]"
    fmt.Println(line[9:14],"#")
--------------------------------------

You can use strings.Split if the columns are separated by a delimiter as long as the delimiter is not part of the data.

--------------------------------------
    line := strings.Split("root	28550	2	0	2015	?	00:00:04	[btrfs-worker]", "\t")
    fmt.Printf("user: %s\tpid:%s\n",line[0],line[1])
--------------------------------------

If you want to work with comma separated values, then use encoding/csv and See above.

=== How do I find the soundex value for a string?

Write soundex yourself, or use a library. A quick searches shows https://github.com/GlobalNamesArchitecture/smetrics/blob/master/soundex.go[this] implementation.

=== How can I expand variables in text strings?

Use https://golang.org/pkg/text/template/[text/template] and wrap the variables in the templating annotations.

If you can not use a template language you can use https://golang.org/pkg/strings/#Replacer[strings.Replacer]

--------------------------------------
    replacer := strings.NewReplacer("foo", "Fred", "bar", "Barney")
    fmt.Println(replacer.Replace("Say Hello to foo and bar"))
--------------------------------------

=== What's wrong with always quoting "$vars"?

Nothing. Go does not expand variables in strings like Perl or PHP. Go's strong static typing prevents the errors that are prevented in Perl by not always quoting vars.

=== Why don't my <<HERE documents work?

Go doesn't have HERE documents, but it does have multiline strings by using backticks.

--------------------------------------
    s := `I do not need
to heredoc
when I can backtick`
--------------------------------------

== Data: Arrays

=== What is the difference between a slice and an array?

Rob Pike has an excellent blog post oh The Go Blog titled http://blog.golang.org/slices["Arrays, slices (and strings): The mechanics of 'append']. That should be background reading for any serious go developer. I'll briefly answer the question here.

Slices wrap array's underneath and expose all sorts of nice things on top of them. You almost always want to use a slice. If you are unsure, then you almost certainly want to use a slice. An array is a contiguous piece of memory. The length of an array is part of its type. In Go, [16]byte and [24]byte are two different types. A slice is a view into an array.

That is the incomplete answer. For the complete answer read the specification and the above blog post.

=== How can I remove duplicate elements from a list or array?

Use a map. When you think the words "unique" or "duplicated" think "map keys".



// vim: set syntax=asciidoc:
